# Глобальна змінна для підрахунку кількості порівнянь
comparison_count = 0


def quick_sort(arr, lo, hi):
    global comparison_count  # Використання глобальної змінної для підрахунку порівнянь
    if lo < hi:
        # Перед початком процедури Partition обміняти місцями перший і останній елементи,
        # роблячи перший елемент опорним
        arr[lo], arr[hi] = arr[hi], arr[lo]

        # Виконуємо процедуру Partition та отримуємо індекс опорного елемента та кількість порівнянь
        p, comps = partition(arr, lo, hi)
        comparison_count += comps  # Додаємо кількість порівнянь до глобальної змінної

        # Рекурсивно виконуємо швидке сортування для лівої та правої частин від опорного елемента
        quick_sort(arr, lo, p - 1)
        quick_sort(arr, p + 1, hi)


def partition(arr, lo, hi):
    # Опорний елемент, який був першим, а тепер останнім після обміну
    pivot = arr[hi]
    i = lo - 1  # Індекс меншого елемента
    comps = 0  # Лічильник порівнянь у цій процедурі Partition
    for j in range(lo, hi):
        comps += 1  # Для кожного елемента додати порівняння
        if arr[j] <= pivot:
            i += 1  # Якщо елемент менший за опорний, змістити його лівіше
            arr[i], arr[j] = arr[j], arr[i]
    # Помістити опорний елемент між двома підмасивами: тими, що менші та більші від нього
    arr[i + 1], arr[hi] = arr[hi], arr[i + 1]
    return i + 1, comps  # Повернути індекс опорного елемента та кількість порівнянь


# Зчитування масиву з файлу для сортування
with open('files/input_10000_numbers.txt', 'r') as file:
    numbers = [int(line.strip()) for line in file]

# Виконання швидкого сортування на масиві
quick_sort(numbers, 0, len(numbers) - 1)

# Вивід загальної кількості порівнянь після сортування
print(f"Загальна кількість порівнянь: {comparison_count}")
